<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Weekly trend</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14; --panel:#11161d; --accent:#3fb950; --text:#e6edf3; --muted:#8b949e; --danger:#f85149; --border:#1f2630; --border2:#30363d; --timeline:#0e141a; --tick:#30363d;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu}
    header{padding:6px 16px;background:var(--panel);border-bottom:1px solid var(--border);display:flex;align-items:center;gap:12px}
    .brand{font-weight:600}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{background:#21262d;color:var(--text);border:1px solid var(--border2);padding:6px 10px;border-radius:6px;cursor:pointer}
    .btn.primary{border-color:var(--accent)}
    .btn[disabled], .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed !important;
      pointer-events: none;
    }
    .pill{padding:4px 8px;border:1px solid var(--border2);border-radius:6px;font-size:13px}
    .label{color:var(--muted);font-size:13px}
    body{display:grid;grid-template-rows:auto auto 1fr auto}
    .timeline{background:var(--panel);border-bottom:1px solid var(--border);padding:10px 16px;z-index:4}
    /* title row with inline controls */
    .timeline-row { display:flex; align-items:center; gap:12px; margin-bottom:2px; flex-wrap:wrap; }
    .timeline-title { font-weight:600; }
    .timeline-wrap{position:relative;background:var(--timeline);border:1px solid var(--border2);border-radius:6px;height:20px;display:grid;align-items:center;overflow:hidden}
    .weeks{position:absolute;inset:0;display:grid;grid-template-columns:repeat(53,1fr);height:100%;z-index:1}
    .week-cell{border-right:1px solid rgba(48,54,61,.6);cursor:pointer}
    .month-labels{position:absolute;left:0;right:0;bottom:2px;display:grid;grid-template-columns:repeat(12,1fr);font-size:11px;color:var(--muted);padding:0 6px;z-index:2;pointer-events:none}
    .marker{position:absolute;top:0;bottom:0;width:3px;background:var(--danger);left:0;transform:translateX(0);z-index:3}
    .marker-head{position:absolute;top:-22px;transform:translateX(-50%);background:var(--danger);border:1px solid rgba(0,0,0,.4);color:#fff;font-size:12px;padding:3px 7px;border-radius:6px;z-index:3}
    #map{height:100%;width:100%;z-index:1}
    footer.panel{background:var(--panel);border-top:1px solid var(--border);padding:10px 16px;display:flex;align-items:center;gap:12px;z-index:3}
    .legend{display:flex;align-items:center;gap:8px}
    .grad{height:10px;width:180px;background:linear-gradient(to right, rgba(0,0,255,0), #2b6cf6, #8dd3ff, #f0f06e, #ff7f00, #ff0000);border:1px solid var(--border2);border-radius:4px}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:9999}
    .overlay .box{background:var(--panel);border:1px solid var(--border2);padding:16px;border-radius:8px;width:min(760px,92vw)}
    .progress{height:8px;background:#1f2630;border-radius:6px;overflow:hidden;margin-top:8px}
    .progress>div{height:100%;width:0%;background:var(--accent);transition:width .15s}
    .small{font-size:12px;color:var(--muted)}
    .debug{font-family:monospace;font-size:12px;color:#cbd5e1;background:#071018;padding:8px;border-radius:6px;max-height:160px;overflow:auto;margin-top:8px}
    .error{color:#ffb4aa;background:#2a0f0f;padding:8px;border-radius:6px;display:none;margin-top:8px}
    .controls-inline { display:flex; gap:8px; align-items:center; }
    .controls-inline select { padding:6px 8px; border-radius:6px; border:1px solid var(--border2); background:#0f1418; color:var(--text); }
    .controls-inline button { padding:6px 8px; border-radius:6px; border:1px solid var(--border2); background:#0f1418; color:var(--text); }
  </style>
</head>
<body>
  <header>
    <div id="brandText" class="brand">Weekly trend</div>
    <div class="controls">
      <input id="fileInput" type="file" accept=".txt,.tsv,.csv" style="display:none" />
      <button id="openGbifOverlay" class="btn primary" type="button">Load GBIF data</button>
      <button id="cancelBtn" class="btn" style="display:none">Cancel</button>

      <div class="pill"><span class="label">Records:</span> <span id="recordCount" class="value">0</span></div>

      <div class="official-controls" title="Overlay official India ADM0 (geoBoundaries)">
        <label style="display:flex;align-items:center;gap:6px;">
          <input id="toggleOfficial" type="checkbox" checked />
          <span class="small">India ADM0 overlay</span>
        </label>
      </div>
	  <div class="timeline-row">
      <div class="controls-inline" style="margin-left:8px;">
        <button id="togglePlayBtn" class="btn primary" disabled>Play</button>
		<button id="prevBtn" class="btn" title="Previous week">◀</button>
        <button id="nextBtn" class="btn" title="Next week">▶</button>
        <label class="small" style="margin-left:6px;">Interval</label>
        <select id="intervalSelect" title="Playback interval">
          <option value="250">0.25 s</option>
          <option value="500" selected>0.5 s</option>
          <option value="750">0.75 s</option>
          <option value="1000">1 s</option>
          <option value="1500">1.5 s</option>
          <option value="2000">2 s</option>
        </select>

        <!-- Week selector -->
        <label class="small" style="margin-left:6px;">Week</label>
        <select id="weekSelect"></select>
      </div>

    </div>
    </div>
  </header>

  <div class="timeline">
    <!-- title row: Week of the year + inline controls (FW/BW, Play/pause, Interval, Week) -->

    <div class="timeline-wrap" id="timelineWrap">
      <div class="weeks" id="weeksGrid"></div>
      <div class="month-labels">
        <div class="month-label">J</div><div class="month-label">F</div><div class="month-label">M</div>
        <div class="month-label">A</div><div class="month-label">M</div><div class="month-label">J</div>
        <div class="month-label">J</div><div class="month-label">A</div><div class="month-label">S</div>
        <div class="month-label">O</div><div class="month-label">N</div><div class="month-label">D</div>
      </div>
      <div class="marker" id="marker"></div>
      <div class="marker-head" id="markerHead">Week 1</div>
    </div>

    <div id="errorBox" class="error"></div>
  </div>

  <div id="map"></div>

  <footer class="panel">
    <div class="legend">
      <div class="label">Intensity</div>
      <div class="grad"></div>
      <div class="small">blue → yellow → red</div>
      <div class="small" style="margin-left:12px;font-size:10px;">Reference map only. Boundaries shown are illustrative; consult official sources for legal status.</div>
    </div>
    <div style="flex:1"></div>
    <div id="citationDisplay" class="small" style="text-align:right;min-height:1.2em;"></div>
  </footer>


  <!-- Startup overlay form -->
  <div class="overlay" id="startupOverlay">
    <form class="box" id="gbifForm" style="display:flex;flex-direction:column;gap:18px;">
      <div style="font-size:1.2em;font-weight:700;">Load GBIF occurrence data</div>
      <div>
        <label style="font-weight:500;">Upload occurrence.txt <span style="color:#f85149">(required)</span></label><br>
        <input id="gbifFileInput" name="occurrenceFile" type="file" accept=".txt,.tsv,.csv" required style="margin-top:6px;" />
        <div class="small">From GBIF, download species occurrences data in Darwin Core Archive format. Unzip occurrence.txt and select for processing.</div>
      </div>
      <div>
        <label style="font-weight:500;">Paste GBIF download citation or DOI <span style="color:#f85149">(required)</span></label><br>
        <textarea id="gbifCitation" name="citation" required rows="2" style="width:100%;margin-top:6px;resize:vertical;min-height:38px;" placeholder="e.g. GBIF.org (2 December 2025) GBIF Occurrence Download https://doi.org/10.15468/dl.ffa8rt"></textarea>
        <div class="small">Paste the full citation from GBIF download page or from the email notification. It will be displayed in the footer.</div>
      </div>
      <div style="display:flex;align-items:center;gap:10px;">
        <input id="gbifConfirm" name="confirm" type="checkbox" required style="width:18px;height:18px;" />
        <label for="gbifConfirm" style="font-weight:600;cursor:pointer;">I confirm this citation is correct and I will cite it when publishing.</label>
      </div>
      <button id="gbifProcessBtn" type="submit" class="btn primary" disabled style="margin-top:8px;width:fit-content;align-self:flex-end;">Process and show data</button>
    </form>
  </div>

  <div class="overlay" id="overlay">
    <div class="box">
      <div style="font-weight:700">Processing occurrence.txt…</div>
      <p id="statusText" class="small">Preparing…</p>
      <div class="progress"><div id="progressBar"></div></div>
      <div id="debugLog" class="debug" aria-live="polite"></div>
    </div>
  </div>

  <script src="geoBoundaries-IND-ADM0.js"></script>

  <script>
    /************************************************************************
     * Precise changes implemented:
     * - Interval options limited to: 0.25, 0.5, 0.75, 1, 1.5, 2 seconds
     * - Controls moved inline on same line as "Week of the year": FW/BW, Play/pause, Interval, Week
     * - Interval change now takes effect immediately during playback
     * - No other behavior changed
     ************************************************************************/

    // --- Map & heat setup (unchanged) ---
    const map = L.map('map', { worldCopyJump: true }).setView([20,78], 3);
    const cartoPositron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; CARTO & OpenStreetMap contributors'
    }).addTo(map);
    const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' });

    const heatLayer = L.heatLayer([], { radius: 8, blur: 15, maxZoom: 6, minOpacity: 0.2 }).addTo(map);

    // UI refs
    const fileInput = document.getElementById('fileInput');
    const cancelBtn = document.getElementById('cancelBtn');
    const overlay = document.getElementById('overlay');
    const progressBar = document.getElementById('progressBar');
    const statusText = document.getElementById('statusText');
    const debugLog = document.getElementById('debugLog');
    const recordCount = document.getElementById('recordCount');
    const weeksGrid = document.getElementById('weeksGrid');
    const weekSelect = document.getElementById('weekSelect');
    const marker = document.getElementById('marker');
    const markerHead = document.getElementById('markerHead');
    const togglePlayBtn = document.getElementById('togglePlayBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const intervalSelect = document.getElementById('intervalSelect');
    const errorBox = document.getElementById('errorBox');
    const brandText = document.getElementById('brandText');
    const openGbifOverlayBtn = document.getElementById('openGbifOverlay');
    const citationDisplay = document.getElementById('citationDisplay');

    // GBIF overlay form refs
    const startupOverlay = document.getElementById('startupOverlay');
    const gbifForm = document.getElementById('gbifForm');
    const gbifFileInput = document.getElementById('gbifFileInput');
    const gbifCitation = document.getElementById('gbifCitation');
    const gbifConfirm = document.getElementById('gbifConfirm');
    const gbifProcessBtn = document.getElementById('gbifProcessBtn');

    // Official overlay refs
    const toggleOfficial = document.getElementById('toggleOfficial');

    // State
    let weeklyData = new Map();
    let availableWeeks = [];
    let totalRecords = 0;
    let animationTimer = null;
    let currentWeekIndex = 0;
    let parserInstance = null;
    let cancelled = false;
    let isPlaying = false;

    // Official overlay state
    let officialLayer = null;
    let originalOfficialGeojson = window.ADM0_GEOJSON || null;
    const OFFICIAL_SIMPLIFY_TOL = 0.01; // fixed as requested

    // Parsing parameters
    const CHUNK_SIZE = 1024 * 1024 * 1; // 1 MB
    const SLICE_ROWS = 3000;           // rows per setTimeout slice
    const USE_WORKER = false;          // set true if running via http server and workers are allowed

    // Helpers
    function log(msg){
      console.log(msg);
      const el = document.createElement('div');
      el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      debugLog.appendChild(el);
      debugLog.scrollTop = debugLog.scrollHeight;
    }
    function showOverlay(show, text){
      overlay.style.display = show ? 'flex' : 'none';
      if (text) statusText.textContent = text;
    }
    function setProgress(pct, text){
      progressBar.style.width = `${pct}%`;
      if (text) statusText.textContent = text;
    }
    function showError(msg){
      errorBox.style.display = 'block';
      errorBox.textContent = msg;
      log('ERROR: ' + msg);
    }
    function clearError(){ errorBox.style.display = 'none'; errorBox.textContent = ''; }

    // --- GBIF overlay form logic ---
    function updateGbifBtnState(){
      const fileOk = gbifFileInput.files && gbifFileInput.files.length > 0;
      const textOk = gbifCitation.value.trim().length > 0;
      const confirmOk = gbifConfirm.checked;
      gbifProcessBtn.disabled = !(fileOk && textOk && confirmOk);
    }
    function showStartupOverlay(resetFields=false){
      if (resetFields){
        gbifForm.reset();
        gbifFileInput.value = '';
      }
      startupOverlay.style.display = 'flex';
      updateGbifBtnState();
    }
    showStartupOverlay(true);
    openGbifOverlayBtn.addEventListener('click', ()=> showStartupOverlay(true));
    gbifFileInput.addEventListener('change', updateGbifBtnState);
    gbifCitation.addEventListener('input', updateGbifBtnState);
    gbifConfirm.addEventListener('change', updateGbifBtnState);
    gbifForm.addEventListener('submit', (e)=>{
      e.preventDefault();
      if (gbifFileInput.files && gbifFileInput.files.length > 0){
        const dt = new DataTransfer();
        dt.items.add(gbifFileInput.files[0]);
        fileInput.files = dt.files;
        fileInput.dataset.gbifCitation = gbifCitation.value.trim();
        fileInput.dataset.gbifConfirmed = gbifConfirm.checked ? '1' : '';
        const citationText = fileInput.dataset.gbifCitation;
        citationDisplay.textContent = citationText ? `GBIF citation: ${citationText}` : '';
        fileInput.dispatchEvent(new Event('change'));
      }
      startupOverlay.style.display = 'none';
    });

    // Date/week helpers
    function toISOWeekFromParts(y,m,d){
      const tmp = new Date(Date.UTC(y,m-1,d));
      if (isNaN(tmp)) return null;
      const dayNum = tmp.getUTCDay() || 7;
      tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(),0,1));
      return Math.ceil((((tmp - yearStart)/86400000)+1)/7);
    }
    function parseWeek(dateStr,y,m,d){
      if (y && m && d) return toISOWeekFromParts(parseInt(y,10),parseInt(m,10),parseInt(d,10));
      if (!dateStr) return null;
      const t = String(dateStr).trim();
      let match = t.match(/^(\d{4})-(\d{2})-(\d{2})/);
      if (match) return toISOWeekFromParts(+match[1],+match[2],+match[3]);
      match = t.match(/^(\d{4})-(\d{2})$/);
      if (match) return toISOWeekFromParts(+match[1],+match[2],15);
      match = t.match(/^(\d{4})$/);
      if (match) return toISOWeekFromParts(+match[1],6,30);
      const djs = new Date(t);
      if (!isNaN(djs)) return toISOWeekFromParts(djs.getUTCFullYear(),djs.getUTCMonth()+1,djs.getUTCDate());
      return null;
    }
    function isValidCoord(lat,lon){
      const la = parseFloat(lat), lo = parseFloat(lon);
      return isFinite(la) && isFinite(lo) && la>=-90 && la<=90 && lo>=-180 && lo<=180;
    }

    function addRecordToWeek(week, lat, lon, weight=1){
      const arr = weeklyData.get(week) || [];
      arr.push([parseFloat(lat), parseFloat(lon), parseFloat(weight) || 1]);
      weeklyData.set(week, arr);
    }

    // UI: weeks grid
    function drawWeeksGrid(){
      weeksGrid.innerHTML = '';
      for (let i=0;i<53;i++){
        const div = document.createElement('div');
        div.className = 'week-cell';
        const weekNum = i+1;
        if (weeklyData.has(weekNum)) div.style.background = 'linear-gradient(to top, rgba(63,185,80,0.12), transparent)';
        div.title = `Week ${weekNum}`;
        div.addEventListener('click', ()=>{ if (weeklyData.has(weekNum)) renderWeek(weekNum); });
        weeksGrid.appendChild(div);
      }
    }

    function moveMarkerToWeekIndex(idx){
      const gridRect = weeksGrid.getBoundingClientRect();
      if (!gridRect.width) return;
      const cellWidth = gridRect.width / 53;
      const x = cellWidth * idx + (cellWidth/2);
      marker.style.transform = `translateX(${x-1}px)`;
      markerHead.style.left = `${x}px`;
    }

    function weekLabelText(week){
      const syntheticYear = 2020;
      function isoWeekStart(year,wk){
        const simple = new Date(Date.UTC(year,0,1 + (wk-1)*7));
        const dow = simple.getUTCDay();
        const ISOweekStart = new Date(simple);
        if (dow <= 4 && dow > 0) ISOweekStart.setUTCDate(simple.getUTCDate() - simple.getUTCDay() + 1);
        else ISOweekStart.setUTCDate(simple.getUTCDate() + (8 - simple.getUTCDay()));
        return ISOweekStart;
      }
      const d = isoWeekStart(syntheticYear, Math.min(Math.max(week,1),53));
      const day = d.getUTCDate();
      const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      return `${day} ${monthNames[d.getUTCMonth()]}`;
    }

    // Render week
    function renderWeek(week){
      const data = weeklyData.get(week) || [];
      heatLayer.setLatLngs(data);
      const idx = availableWeeks.indexOf(week);
      if (idx !== -1){
        currentWeekIndex = idx;
        moveMarkerToWeekIndex(idx);
        const label = weekLabelText(week);
        markerHead.textContent = label;
        weekSelect.value = String(week);
      }
    }

    function updateAvailableWeeks(){
      availableWeeks = Array.from(weeklyData.keys()).sort((a,b)=>a-b);
      weekSelect.innerHTML = availableWeeks.map(w => `<option value="${w}">${weekLabelText(w)}</option>`).join('');
      drawWeeksGrid();
      if (availableWeeks.length){
        moveMarkerToWeekIndex(0);
        markerHead.textContent = weekLabelText(availableWeeks[0]);
      }
    }

    // Playback (single toggle)
    function play(intervalMs){
      if (!availableWeeks.length) return;
      isPlaying = true;
      togglePlayBtn.textContent = 'Pause';
      const interval = intervalMs || parseInt(intervalSelect.value,10);
      if (animationTimer) clearInterval(animationTimer);
      animationTimer = setInterval(()=>{
        renderWeek(availableWeeks[currentWeekIndex]);
        currentWeekIndex = (currentWeekIndex + 1) % availableWeeks.length;
      }, interval);
    }
    function pause(){
      isPlaying = false;
      togglePlayBtn.textContent = 'Play';
      if (animationTimer) clearInterval(animationTimer);
      animationTimer = null;
    }
    function togglePlay(){
      if (isPlaying) pause(); else play();
    }

    // --- make interval changes dynamic while playing ---
    function restartPlaybackWithNewInterval() {
      if (!isPlaying) return;
      if (animationTimer) clearInterval(animationTimer);
      const interval = parseInt(intervalSelect.value, 10) || 250;
      animationTimer = setInterval(() => {
        renderWeek(availableWeeks[currentWeekIndex]);
        currentWeekIndex = (currentWeekIndex + 1) % availableWeeks.length;
      }, interval);
    }
    intervalSelect.addEventListener('change', () => {
      if (isPlaying) restartPlaybackWithNewInterval();
    });

    // Wire playback UI
    togglePlayBtn.addEventListener('click', ()=> togglePlay());
    prevBtn.addEventListener('click', ()=>{ pause(); if (!availableWeeks.length) return; currentWeekIndex = (currentWeekIndex - 1 + availableWeeks.length) % availableWeeks.length; renderWeek(availableWeeks[currentWeekIndex]); });
    nextBtn.addEventListener('click', ()=>{ pause(); if (!availableWeeks.length) return; currentWeekIndex = (currentWeekIndex + 1) % availableWeeks.length; renderWeek(availableWeeks[currentWeekIndex]); });
    weekSelect.addEventListener('change', ()=>{ pause(); renderWeek(parseInt(weekSelect.value,10)); });

    // Spacebar toggles play/pause (unless focused on an input)
    window.addEventListener('keydown', (e) => {
      const active = document.activeElement;
      const isInput = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.tagName === 'SELECT' || active.isContentEditable);
      if (e.code === 'Space' && !isInput) {
        e.preventDefault();
        if (!togglePlayBtn.disabled) togglePlay();
      }
    });

    // Cancel parsing
    cancelBtn.addEventListener('click', ()=>{
      cancelled = true;
      if (parserInstance && typeof parserInstance.abort === 'function') {
        try { parserInstance.abort(); } catch(e){ /* ignore */ }
      }
      showOverlay(false);
      cancelBtn.style.display = 'none';
      log('Parsing cancelled by user.');
    });

    /************************************************************************
     * Robust parsing using Papa.parse chunk + non-blocking slices
     * Also: detect common name from uploaded file and set header text.
     ************************************************************************/

    function detectCommonNameFromRow(row){
      if (!row || typeof row !== 'object') return null;
      const keys = Object.keys(row).map(k => k.toLowerCase());
      const candidates = ['vernacularname','commonname','species','speciesname','taxon','scientificname','taxonname','vernacularName','commonName'];
      for (const c of candidates){
        for (const k of Object.keys(row)){
          if (k.toLowerCase() === c && row[k]) return String(row[k]).trim();
        }
      }
      for (const k of Object.keys(row)){
        const v = row[k];
        if (!v) continue;
        const s = String(v);
        const m = s.match(/\(([^)]+)\)/);
        if (m && m[1]) return m[1].trim();
      }
      return null;
    }

    function setBrandFromCommonName(name){
      if (!name) {
        brandText.textContent = 'Weekly trend';
      } else {
        brandText.textContent = `${name} - Weekly trend`;
      }
    }

    fileInput.addEventListener('change', ()=>{
      const file = fileInput.files[0];
      if (!file) return;

      // reset
      weeklyData = new Map(); availableWeeks = []; totalRecords = 0; currentWeekIndex = 0;
      heatLayer.setLatLngs([]); recordCount.textContent = '0';
      clearError(); debugLog.innerHTML = ''; drawWeeksGrid();
      togglePlayBtn.disabled = true; // will enable after parse
      cancelled = false;
      setBrandFromCommonName(null); // reset brand until detected

      showOverlay(true, `Reading ${Math.round(file.size/1024/1024)} MB…`);
      setProgress(0, 'Starting parse…');
      log('Selected file: ' + file.name + ' (' + Math.round(file.size/1024/1024) + ' MB)');

      // quick delimiter check
      const headReader = new FileReader();
      headReader.onload = ()=>{
        const head = headReader.result.slice(0,50000);
        const tabCount = (head.match(/\t/g) || []).length;
        const commaCount = (head.match(/,/g) || []).length;
        if (tabCount < 3 && commaCount > tabCount){
          showOverlay(false);
          showError('File appears comma-delimited; please upload tab-delimited occurrence.txt.');
          return;
        }
        // start streaming parse
        startStreamingParse(file);
      };
      headReader.readAsText(file.slice(0, Math.min(1024*64, file.size)));
    });

    function startStreamingParse(file){
      let headerValidated = false;
      let invalidHeader = false;
      let processedBytes = 0;
      let detectedCommonName = null;

      function handleChunkRows(rows, doneChunk){
        if (cancelled) { doneChunk(); return; }
        if (!detectedCommonName){
          for (let r of rows){
            const cn = detectCommonNameFromRow(r);
            if (cn) { detectedCommonName = cn; setBrandFromCommonName(cn); break; }
          }
        }
        let i = 0;
        function processSlice(){
          if (cancelled) { doneChunk(); return; }
          const end = Math.min(i + SLICE_ROWS, rows.length);
          for (; i < end; i++){
            const data = rows[i];
            const lat = data['decimalLatitude'];
            const lon = data['decimalLongitude'];
            const dateStr = data['eventDate'] || data['verbatimEventDate'] || null;
            const y = data['year'], m = data['month'], d = data['day'];
            if (!isValidCoord(lat,lon)) continue;
            const week = parseWeek(dateStr, y, m, d);
            if (week == null || week < 1 || week > 53) continue;
            let weight = 1;
            if (data['individualCount'] !== undefined && data['individualCount'] !== '') {
              const w = parseFloat(data['individualCount']);
              if (!isNaN(w) && w > 0) weight = w;
            } else if (data['occurrenceCount'] !== undefined && data['occurrenceCount'] !== '') {
              const w = parseFloat(data['occurrenceCount']);
              if (!isNaN(w) && w > 0) weight = w;
            }
            addRecordToWeek(week, lat, lon, weight);
            totalRecords++;
          }
          setProgress(Math.min(99, (processedBytes / file.size) * 100), `Parsed ${totalRecords.toLocaleString()} rows…`);
          recordCount.textContent = totalRecords.toLocaleString();
          if (i < rows.length) {
            setTimeout(processSlice, 0);
          } else {
            doneChunk();
          }
        }
        processSlice();
      }

      cancelled = false;
      cancelBtn.style.display = 'inline-block';
      try {
        parserInstance = Papa.parse(file, {
          header: true,
          delimiter: '\t',
          worker: USE_WORKER,
          skipEmptyLines: true,
          chunkSize: CHUNK_SIZE,
          chunk: function(results, parser){
            if (cancelled) { parser.abort(); return; }
            const rows = results.data;
            processedBytes = results.meta && results.meta.cursor ? results.meta.cursor : processedBytes;
            if (!headerValidated){
              headerValidated = true;
              const cols = Object.keys(rows[0] || {});
              const hasCoords = cols.includes('decimalLatitude') && cols.includes('decimalLongitude');
              const hasDate = cols.includes('eventDate') || (cols.includes('year') && cols.includes('month') && cols.includes('day')) || cols.includes('verbatimEventDate');
              if (!hasCoords || !hasDate){
                invalidHeader = true;
                parser.abort();
                showOverlay(false);
                showError('Missing required headers: eventDate/verbatimEventDate or year/month/day, and decimalLatitude/decimalLongitude.');
                return;
              }
              const cn = detectCommonNameFromRow(rows[0]);
              if (cn) { setBrandFromCommonName(cn); }
            }
            parser.pause();
            handleChunkRows(rows, ()=>{
              if (!cancelled) parser.resume();
            });
          },
          complete: function(){
            cancelBtn.style.display = 'none';
            if (invalidHeader) return;
            setProgress(99, 'Finalizing frames…');
            downsampleWeekArrays(20000);
            updateAvailableWeeks();
            showOverlay(false);
            if (availableWeeks.length){
              togglePlayBtn.disabled = false;
              currentWeekIndex = 0;
              renderWeek(availableWeeks[0]);
              setTimeout(()=>map.invalidateSize(),50);
            } else {
              showError('No valid weekly frames constructed (dates may be non-week-resolvable).');
            }
          },
          error: function(err){
            cancelBtn.style.display = 'none';
            showOverlay(false);
            showError('Parsing error: ' + (err && err.message ? err.message : String(err)));
          }
        });
      } catch (e){
        cancelBtn.style.display = 'none';
        showOverlay(true, 'Chunked parse failed; falling back to manual slice read');
        log('Papa.parse chunk failed: ' + (e && e.message ? e.message : String(e)));
        fallbackManualRead(file);
      }
    }

    // Fallback manual read
    function fallbackManualRead(file){
      const SLICE_BYTES = 1024 * 1024 * 1; // 1MB
      let offset = 0;
      let headerValidated = false;
      let invalidHeader = false;
      let detectedCommonName = null;

      function readNextSlice(){
        if (offset >= file.size) {
          setProgress(99, 'Finalizing frames…');
          downsampleWeekArrays(20000);
          updateAvailableWeeks();
          showOverlay(false);
          if (availableWeeks.length){
            togglePlayBtn.disabled = false;
            currentWeekIndex = 0;
            renderWeek(availableWeeks[0]);
            setTimeout(()=>map.invalidateSize(),50);
          } else {
            showError('No valid weekly frames constructed.');
          }
          return;
        }
        const end = Math.min(offset + SLICE_BYTES, file.size);
        const slice = file.slice(offset, end);
        const reader = new FileReader();
        reader.onload = () => {
          const text = reader.result;
          const config = {
            header: offset === 0,
            delimiter: '\t',
            skipEmptyLines: true
          };
          const parsed = Papa.parse(text, config);
          if (parsed && parsed.data && parsed.data.length){
            if (!headerValidated && parsed.meta && parsed.meta.fields){
              headerValidated = true;
              const cols = parsed.meta.fields;
              const hasCoords = cols.includes('decimalLatitude') && cols.includes('decimalLongitude');
              const hasDate = cols.includes('eventDate') || (cols.includes('year') && cols.includes('month') && cols.includes('day')) || cols.includes('verbatimEventDate');
              if (!hasCoords || !hasDate){
                invalidHeader = true;
                showOverlay(false);
                showError('Missing required headers: eventDate/year/month/day and decimalLatitude/decimalLongitude.');
                return;
              }
              const cn = detectCommonNameFromRow(parsed.data[0]);
              if (cn) { detectedCommonName = cn; setBrandFromCommonName(cn); }
            }
            let rows = parsed.data;
            if (!detectedCommonName){
              for (let r of rows){
                const cn = detectCommonNameFromRow(r);
                if (cn) { detectedCommonName = cn; setBrandFromCommonName(cn); break; }
              }
            }
            let i = 0;
            function processSliceRows(){
              const endIdx = Math.min(i + SLICE_ROWS, rows.length);
              for (; i < endIdx; i++){
                const data = rows[i];
                const lat = data['decimalLatitude'];
                const lon = data['decimalLongitude'];
                const dateStr = data['eventDate'] || data['verbatimEventDate'] || null;
                const y = data['year'], m = data['month'], d = data['day'];
                if (!isValidCoord(lat,lon)) continue;
                const week = parseWeek(dateStr, y, m, d);
                if (week == null || week < 1 || week > 53) continue;
                let weight = 1;
                if (data['individualCount'] !== undefined && data['individualCount'] !== '') {
                  const w = parseFloat(data['individualCount']);
                  if (!isNaN(w) && w > 0) weight = w;
                } else if (data['occurrenceCount'] !== undefined && data['occurrenceCount'] !== '') {
                  const w = parseFloat(data['occurrenceCount']);
                  if (!isNaN(w) && w > 0) weight = w;
                }
                addRecordToWeek(week, lat, lon, weight);
                totalRecords++;
              }
              setProgress(Math.min(99, (end / file.size) * 100), `Parsed ${totalRecords.toLocaleString()} rows…`);
              recordCount.textContent = totalRecords.toLocaleString();
              if (i < rows.length) setTimeout(processSliceRows, 0);
              else {
                offset = end;
                setTimeout(readNextSlice, 0);
              }
            }
            processSliceRows();
          } else {
            offset = end;
            setTimeout(readNextSlice, 0);
          }
        };
        reader.onerror = () => {
          showOverlay(false);
          showError('File read error during fallback read.');
        };
        reader.readAsText(slice);
      }
      readNextSlice();
    }

    // Downsample large weekly arrays
    function downsampleWeekArrays(maxPerWeek=20000){
      weeklyData.forEach((arr, week)=>{
        if (arr.length > maxPerWeek){
          const factor = maxPerWeek / arr.length;
          const sampled = [];
          for (let i=0;i<arr.length;i++) if (Math.random() < factor) sampled.push(arr[i]);
          weeklyData.set(week, sampled);
        }
      });
    }

    // Keep marker aligned on resize
    window.addEventListener('resize', ()=> moveMarkerToWeekIndex(currentWeekIndex));

    // init
    drawWeeksGrid();
    log('Ready. Select occurrence.txt to start parsing.');

    /************************************************************************
     * Official India ADM0 overlay (geoBoundaries) integration
     ************************************************************************/

    const GEOJSON_URL = './geoBoundaries-IND-ADM0.geojson';

    function fetchGeoJSONViaXHR(url){
      return new Promise((resolve)=>{
        try {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.overrideMimeType('application/json');
          xhr.onreadystatechange = () => {
            if (xhr.readyState !== 4) return;
            if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)){
              try {
                resolve(JSON.parse(xhr.responseText));
              } catch (e) {
                console.error('Failed to parse ADM0 JSON from XHR', e);
                resolve(null);
              }
            } else {
              resolve(null);
            }
          };
          xhr.onerror = () => resolve(null);
          xhr.send();
        } catch (err){
          console.error('XHR fallback failed', err);
          resolve(null);
        }
      });
    }

    async function fetchOfficialGeoJSON(){
      if (originalOfficialGeojson) {
        return originalOfficialGeojson;
      }
      try {
        const res = await fetch(GEOJSON_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const geo = await res.json();
        originalOfficialGeojson = geo;
        return geo;
      } catch (err) {
        console.error(err);
        const xhrGeo = await fetchGeoJSONViaXHR(GEOJSON_URL);
        if (xhrGeo) {
          originalOfficialGeojson = xhrGeo;
          window.ADM0_GEOJSON = xhrGeo;
          return xhrGeo;
        }
        showError('Failed to load official GeoJSON from geoBoundaries-IND-ADM0.geojson. Please ensure it is located beside this HTML file and is readable.');
        return null;
      }
    }

    function styleOfficialFeature(){
      return {
        color: '#666666',
        weight: 1.8,
        opacity: 0.95,
        fill: true,
        fillColor: '#f2efe9',
        fillOpacity: 0.12
      };
    }

    function addOfficialToMap(geojson){
      if (officialLayer) {
        map.removeLayer(officialLayer);
        officialLayer = null;
      }
      let processed = geojson;
      if (OFFICIAL_SIMPLIFY_TOL && OFFICIAL_SIMPLIFY_TOL > 0) {
        try {
          processed = turf.simplify(geojson, { tolerance: OFFICIAL_SIMPLIFY_TOL, highQuality: false });
        } catch (e) {
          console.warn('Simplify failed, using original geojson', e);
          processed = geojson;
        }
      }
      officialLayer = L.geoJSON(processed, {
        style: styleOfficialFeature,
        pane: 'overlayPane',
        onEachFeature: function (feature, layer) {
          const props = feature.properties || {};
          const title = props.name || props.NAME || props.admin || 'India ADM0';
          layer.bindPopup(title);
        }
      });
      if (toggleOfficial.checked) officialLayer.addTo(map);
    }

    toggleOfficial.addEventListener('change', async (e) => {
      if (!originalOfficialGeojson) {
        const geo = await fetchOfficialGeoJSON();
        if (!geo) return;
        addOfficialToMap(geo);
        return;
      }
      if (!officialLayer) addOfficialToMap(originalOfficialGeojson);
      if (e.target.checked) {
        if (officialLayer && !map.hasLayer(officialLayer)) officialLayer.addTo(map);
      } else {
        if (officialLayer && map.hasLayer(officialLayer)) map.removeLayer(officialLayer);
      }
    });

    (async ()=> {
      const geo = await fetchOfficialGeoJSON();
      if (geo) addOfficialToMap(geo);
    })();

    // Ensure map resizes correctly after everything loads
    setTimeout(()=> map.invalidateSize(), 200);
  </script>
</body>
</html>