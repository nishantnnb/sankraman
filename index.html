<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Weekly trend</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

  <style>
    :root{
      --bg:#0b0f14; --panel:#11161d; --accent:#3fb950; --text:#e6edf3; --muted:#8b949e; --danger:#f85149; --border:#1f2630; --border2:#30363d; --timeline:#0e141a; --tick:#30363d;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu}
    
    body{display:grid; grid-template-columns: 1fr 260px; grid-template-rows: 100vh; overflow:hidden;}
    
    /* Main Left Panel */
    #mainPanel { display:grid; grid-template-rows:auto 1fr auto; height:100%; position:relative; overflow:hidden; }
    
    /* Sidebar Right */
    #sidebar { background:var(--panel); border-left:1px solid var(--border); padding:20px; display:flex; flex-direction:column; gap:24px; overflow-y:auto; z-index:10; box-shadow:-4px 0 10px rgba(0,0,0,0.1); }
    
    .sidebar-section { display:flex; flex-direction:column; gap:10px; }
    .sidebar-title { font-weight:600; font-size:14px; color:var(--muted); text-transform:uppercase; letter-spacing:0.5px; margin-bottom:4px; }
    .brand { font-size:18px; font-weight:700; margin-bottom:10px; color:var(--text); border-bottom:1px solid var(--border2); padding-bottom:16px; }
    
    .btn{background:#21262d;color:var(--text);border:1px solid var(--border2);padding:8px 12px;border-radius:6px;cursor:pointer; width:100%; text-align:center; transition:background 0.2s;}
    .btn:hover { background:#30363d; }
    .btn.primary{border-color:var(--accent); background:rgba(63,185,80,0.1); color:#56d364;}
    .btn.primary:hover { background:rgba(63,185,80,0.2); }
    .btn[disabled], .btn:disabled { opacity: 0.5; cursor: not-allowed !important; pointer-events: none; }
    
    .row-group { display:flex; gap:8px; }
    .row-group > * { flex:1; }
    
    select { background:#0d1117; border:1px solid var(--border2); color:var(--text); padding:8px; border-radius:6px; width:100%; }
    
    .pill{padding:4px 0; font-size:13px; display:flex; justify-content:space-between; color:var(--muted); border-bottom:1px solid var(--border); padding-bottom:8px;}
    .pill .value { color:var(--text); font-weight:600; font-family:monospace; }
    
    .checkbox-label { display:flex; align-items:center; gap:8px; cursor:pointer; font-size:13px; color:var(--text); padding:6px 0; }
    
    /* Timeline styles */
    .timeline{background:var(--panel);border-bottom:1px solid var(--border);padding:12px 16px;z-index:4}
    .timeline-wrap{position:relative;background:var(--timeline);border:1px solid var(--border2);border-radius:6px;height:44px;overflow:hidden;}
    
    .months-layer { position:absolute; top:0; left:0; right:0; height:20px; pointer-events:none; z-index:2; }
    .month-label { position:absolute; top:0; bottom:0; display:flex; align-items:center; justify-content:center; font-size:11px; color:var(--muted); border-left:1px solid rgba(255,255,255,0.15); box-sizing:border-box; overflow:hidden; white-space:nowrap; background:rgba(0,0,0,0.1); }
    .month-label:first-child { border-left:none; }
    
    .weeks-layer { position:absolute; top:20px; left:0; right:0; bottom:0; display:grid; grid-template-columns:repeat(52,1fr); z-index:1; }
    
    .week-cell{border-right:1px solid rgba(48,54,61,.3);cursor:pointer; text-align:center; font-size:10px; color:var(--muted); background:transparent; display:flex; align-items:center; justify-content:center; position:relative;}
    .week-cell:hover { background:rgba(255,255,255,0.05); color:var(--text); }
    .week-cell.has-data { color:var(--text); font-weight:600; }
    .week-cell.active { background:rgba(63,185,80,0.2); }
    
    .marker{position:absolute;top:20px;bottom:0;width:3px;background:var(--danger);left:0;transform:translateX(0);z-index:3;pointer-events:none;transition:transform 0.1s linear;}
    .marker-head{position:absolute;top:-22px;transform:translateX(-50%);background:var(--danger);border:1px solid rgba(0,0,0,.4);color:#fff;font-size:12px;padding:3px 7px;border-radius:6px;z-index:3; white-space:nowrap;}
    
    #map{height:100%;width:100%;z-index:1}
    footer.panel{background:var(--panel);border-top:1px solid var(--border);padding:8px 16px;display:flex;align-items:center;gap:16px;z-index:3; flex-wrap:wrap;}
    .legend{display:flex;align-items:center;gap:8px}
    .grad{height:10px;width:180px;background:linear-gradient(to right, rgba(0,0,255,0), #2b6cf6, #8dd3ff, #f0f06e, #ff7f00, #ff0000);border:1px solid var(--border2);border-radius:4px}
    .footer-text { font-size:11px; color:var(--muted); line-height:1.3; }
    .footer-group { display:flex; gap:16px; align-items:center; }

    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:9999}
    .overlay .box{background:var(--panel);border:1px solid var(--border2);padding:16px;border-radius:8px;width:min(760px,92vw)}
    .progress{height:8px;background:#1f2630;border-radius:6px;overflow:hidden;margin-top:8px}
    .progress>div{height:100%;width:0%;background:var(--accent);transition:width .15s}
    .small{font-size:12px;color:var(--muted)}
    .debug{font-family:monospace;font-size:12px;color:#cbd5e1;background:#071018;padding:8px;border-radius:6px;max-height:160px;overflow:auto;margin-top:8px}
    .error{color:#ffb4aa;background:#2a0f0f;padding:8px;border-radius:6px;display:none;margin-top:8px}
    
    /* Phone Export Mode Overrides */
    .export-mode-phone .timeline-wrap { height: 70px !important; }
    .export-mode-phone .months-layer { height: 36px !important; }
    .export-mode-phone .month-label { font-size: 22px !important; font-weight: 500 !important; color: #fff !important; background:rgba(0,0,0,0.3) !important; border-left: 2px solid rgba(255,255,255,0.3) !important;}
    .export-mode-phone .weeks-layer { top: 36px !important; }
    .export-mode-phone .week-cell { border-right: none !important; font-size: 14px !important; } /* Cleaner look, bigger font */
    .export-mode-phone .footer-text { font-size: 16px !important; font-weight:500; }
    .export-mode-phone #citationDisplay { display: none !important; } /* Hide in footer, show in banner */
    .export-mode-phone #mapSpeciesLabel { display: none !important; } /* Redundant in Phone mode */
    .export-mode-phone .marker { width: 4px !important; background: #ff3333 !important; }
    .export-mode-phone .marker-head { font-size: 18px !important; top: -30px !important; padding: 4px 10px !important; }
  </style>
</head>
<body>
  
  <main id="mainPanel">
    <div class="timeline">
      <div class="timeline-wrap" id="timelineWrap">
        <div class="months-layer"></div>
        <div class="weeks-layer"></div>
        <div class="marker" id="marker"></div>
        <div class="marker-head" id="markerHead">Week 1</div>
      </div>
      <div id="errorBox" class="error"></div>
    </div>

    <div id="map"></div>
    <div id="mapSpeciesLabel" style="position:absolute; top:60px; right:20px; background:rgba(0,0,0,0.5); color:#fff; padding:8px 12px; border-radius:6px; font-weight:700; font-size:16px; pointer-events:none; display:none; z-index:400; backdrop-filter:blur(2px);"></div>

    <footer class="panel">
      <div class="legend">
        <div class="footer-text">Intensity</div>
        <div class="grad"></div>
        <div class="footer-text">blue → yellow → red</div>
      </div>
      
      <div class="footer-group">
        <div class="footer-text">
          Illustrative Map.<br>
          For official maps, refer respective legal sources.
        </div>
        <div id="citationDisplay" class="footer-text" style="min-height:1.2em; max-width:400px;"></div>
      </div>
    </footer>
  </main>

  <aside id="sidebar">
    <div id="brandText" class="brand">Weekly trend</div>
    
    <div class="sidebar-section">
      <div class="sidebar-title">Data</div>
      <input id="fileInput" type="file" accept=".txt,.tsv,.csv" style="display:none" />
      <button id="openGbifOverlay" class="btn primary" type="button">Load GBIF Data</button>
      <button id="cancelBtn" class="btn" style="display:none">Cancel Parse</button>
      
      <div class="pill"><span>Records</span> <span id="recordCount" class="value">0</span></div>
    </div>

    <div class="sidebar-section">
      <div class="sidebar-title">Map Layers</div>
      <label class="checkbox-label" title="Overlay official India ADM0 (geoBoundaries)">
        <input id="toggleOfficial" type="checkbox" checked />
        <span>India ADM0 Overlay</span>
      </label>
    </div>

    <div class="sidebar-section">
      <div class="sidebar-title">Playback</div>
      <button id="togglePlayBtn" class="btn primary" disabled>Play</button>
      <div class="row-group">
        <button id="prevBtn" class="btn" title="Previous week">◀ Prev</button>
        <button id="nextBtn" class="btn" title="Next week">Next ▶</button>
      </div>
      
      <div style="margin-top:8px;">
        <div class="sidebar-title" style="font-size:12px;margin-bottom:4px;">Speed</div>
        <select id="intervalSelect" title="Playback interval">
          <option value="250">0.25 s (Fast)</option>
          <option value="500" selected>0.5 s</option>
          <option value="750">0.75 s</option>
          <option value="1000">1 s (Slow)</option>
          <option value="1500">1.5 s</option>
          <option value="2000">2 s</option>
        </select>
      </div>
      
      <div style="margin-top:8px;">
        <div class="sidebar-title" style="font-size:12px;margin-bottom:4px;">Video Style</div>
        <select id="videoLayoutSelect">
          <option value="desktop">Desktop (Standard)</option>
          <option value="phone">Phone (Social Media)</option>
        </select>
      </div>

      <button id="downloadVideoBtn" class="btn" style="margin-top:16px;">Download Video</button>
    </div>

  </aside>

  <!-- Startup overlay form -->
  <div class="overlay" id="startupOverlay">
    <form class="box" id="gbifForm" style="display:flex;flex-direction:column;gap:18px;position:relative;">
      <div style="font-size:1.2em;font-weight:700;">Load GBIF occurrence data</div>
      <div>
        <label style="font-weight:500;">Upload occurrence.txt <span style="color:#f85149">(required)</span></label><br>
        <input id="gbifFileInput" name="occurrenceFile" type="file" accept=".txt,.tsv,.csv" required style="margin-top:6px;" />
        <div class="small">From GBIF, download species occurrences data in Darwin Core Archive format. Unzip occurrence.txt and select for processing.</div>
      </div>
      <div>
        <label style="font-weight:500;">Species Name for Display <span class="small" style="font-weight:400;color:var(--muted)">(optional)</span></label><br>
        <input id="gbifSpeciesName" name="speciesName" type="text" style="width:100%;margin-top:6px;padding:8px;border-radius:4px;border:1px solid var(--border2);background:#0d1117;color:var(--text);" placeholder="e.g. House Sparrow" />
      </div>
      <div>
        <label style="font-weight:500;">Paste GBIF download citation or DOI <span style="color:#f85149">(required)</span></label><br>
        <textarea id="gbifCitation" name="citation" required rows="2" style="width:100%;margin-top:6px;resize:vertical;min-height:38px;" placeholder="e.g. GBIF.org (2 December 2025) GBIF Occurrence Download https://doi.org/10.15468/dl.ffa8rt"></textarea>
        <div class="small">Paste the full citation from GBIF download page or from the email notification. It will be displayed in the footer.</div>
      </div>
      <div style="display:flex;align-items:center;gap:10px;">
        <input id="gbifConfirm" name="confirm" type="checkbox" required style="width:18px;height:18px;" />
        <label for="gbifConfirm" style="font-weight:600;cursor:pointer;">I confirm this citation is correct and I will cite it when publishing.</label>
      </div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;">
        <button id="gbifProcessBtn" type="submit" class="btn primary" disabled style="width:fit-content;">Process and show data</button>
        <button id="gbifCancelBtn" type="button" class="btn" style="margin-left:12px;">Cancel</button>
      </div>
    </form>
  </div>

  <div class="overlay" id="overlay">
    <div class="box">
      <div id="overlayTitle" style="font-weight:700">Processing occurrence.txt…</div>
      <p id="statusText" class="small">Preparing…</p>
      <div class="progress"><div id="progressBar"></div></div>
      <div id="debugLog" class="debug" aria-live="polite"></div>
    </div>
  </div>

  <script src="geoBoundaries-IND-ADM0.js"></script>

  <script>
    /************************************************************************
     * Precise changes implemented:
     * - Interval options limited to: 0.25, 0.5, 0.75, 1, 1.5, 2 seconds
     * - Controls moved inline on same line as "Week of the year": FW/BW, Play/pause, Interval, Week
     * - Interval change now takes effect immediately during playback
     * - No other behavior changed
     ************************************************************************/

    // --- Map & heat setup (unchanged) ---
    const map = L.map('map', { 
      worldCopyJump: true,
      zoomSnap: 0.1,
      zoomDelta: 0.1,
      preferCanvas: true
    }).setView([20,78], 3);
    const cartoPositron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; CARTO & OpenStreetMap contributors',
      crossOrigin: 'anonymous'
    }).addTo(map);
    const osm = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' });

    const heatLayer = L.heatLayer([], { radius: 8, blur: 15, maxZoom: 6, minOpacity: 0.2 }).addTo(map);

    // UI refs
    const fileInput = document.getElementById('fileInput');
    const cancelBtn = document.getElementById('cancelBtn');
    const overlay = document.getElementById('overlay');
    const progressBar = document.getElementById('progressBar');
    const statusText = document.getElementById('statusText');
    const debugLog = document.getElementById('debugLog');
    const recordCount = document.getElementById('recordCount');
    const timelineWrap = document.getElementById('timelineWrap');
    // weekSelect removed
    const marker = document.getElementById('marker');
    const markerHead = document.getElementById('markerHead');
    const togglePlayBtn = document.getElementById('togglePlayBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const intervalSelect = document.getElementById('intervalSelect');
    const errorBox = document.getElementById('errorBox');
    const brandText = document.getElementById('brandText');
    const openGbifOverlayBtn = document.getElementById('openGbifOverlay');
    const citationDisplay = document.getElementById('citationDisplay');
    const downloadVideoBtn = document.getElementById('downloadVideoBtn');
    const overlayTitle = document.getElementById('overlayTitle');
    const videoLayoutSelect = document.getElementById('videoLayoutSelect');
    
    // New Refs
    const gbifSpeciesName = document.getElementById('gbifSpeciesName');
    const mapSpeciesLabel = document.getElementById('mapSpeciesLabel');

    // GBIF overlay form refs
    const startupOverlay = document.getElementById('startupOverlay');
    const gbifForm = document.getElementById('gbifForm');
    const gbifFileInput = document.getElementById('gbifFileInput');
    const gbifCitation = document.getElementById('gbifCitation');
    const gbifConfirm = document.getElementById('gbifConfirm');
    const gbifProcessBtn = document.getElementById('gbifProcessBtn');
    const gbifCancelBtn = document.getElementById('gbifCancelBtn');

    // Official overlay refs
    const toggleOfficial = document.getElementById('toggleOfficial');

    // State
    let weeklyData = new Map();
    let availableWeeks = [];
    let totalRecords = 0;
    let animationTimer = null;
    let currentWeekIndex = 0;
    let parserInstance = null;
    let cancelled = false;
    let isPlaying = false;

    // Official overlay state
    let officialLayer = null;
    let originalOfficialGeojson = window.ADM0_GEOJSON || null;
    const OFFICIAL_SIMPLIFY_TOL = 0.01; // fixed as requested

    // Parsing parameters
    const CHUNK_SIZE = 1024 * 1024 * 1; // 1 MB
    const SLICE_ROWS = 3000;           // rows per setTimeout slice
    const USE_WORKER = false;          // set true if running via http server and workers are allowed

    // Helpers
    function log(msg){
      console.log(msg);
      const el = document.createElement('div');
      el.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      debugLog.appendChild(el);
      debugLog.scrollTop = debugLog.scrollHeight;
    }
    function showOverlay(show, text){
      overlay.style.display = show ? 'flex' : 'none';
      if (text) statusText.textContent = text;
    }
    function setProgress(pct, text){
      progressBar.style.width = `${pct}%`;
      if (text) statusText.textContent = text;
    }
    function showError(msg){
      errorBox.style.display = 'block';
      errorBox.textContent = msg;
      log('ERROR: ' + msg);
    }
    function clearError(){ errorBox.style.display = 'none'; errorBox.textContent = ''; }

    // --- GBIF overlay form logic ---
    function updateGbifBtnState(){
      const fileOk = gbifFileInput.files && gbifFileInput.files.length > 0;
      const textOk = gbifCitation.value.trim().length > 0;
      const confirmOk = gbifConfirm.checked;
      gbifProcessBtn.disabled = !(fileOk && textOk && confirmOk);
    }
    function showStartupOverlay(resetFields=false){
      if (resetFields){
        gbifForm.reset();
        gbifFileInput.value = '';
      }
      startupOverlay.style.display = 'flex';
      updateGbifBtnState();
      pause(); // Pause playback when overlay opens
    }
        gbifCancelBtn.addEventListener('click', () => {
          startupOverlay.style.display = 'none';
        });
    showStartupOverlay(true);
    openGbifOverlayBtn.addEventListener('click', ()=> showStartupOverlay(true));
    gbifFileInput.addEventListener('change', updateGbifBtnState);
    gbifCitation.addEventListener('input', updateGbifBtnState);
    gbifConfirm.addEventListener('change', updateGbifBtnState);
    gbifForm.addEventListener('submit', (e)=>{
      e.preventDefault();
      if (gbifFileInput.files && gbifFileInput.files.length > 0){
        const dt = new DataTransfer();
        dt.items.add(gbifFileInput.files[0]);
        fileInput.files = dt.files;
        fileInput.dataset.gbifCitation = gbifCitation.value.trim();
        fileInput.dataset.gbifConfirmed = gbifConfirm.checked ? '1' : '';
        fileInput.dataset.manualSpeciesName = gbifSpeciesName.value.trim(); // Save manual name
        
        const citationText = fileInput.dataset.gbifCitation;
        citationDisplay.textContent = citationText ? `GBIF citation: ${citationText}` : '';
        fileInput.dispatchEvent(new Event('change'));
      }
      startupOverlay.style.display = 'none';
    });

    // Date/week helpers
    function toISOWeekFromParts(y,m,d){
      const tmp = new Date(Date.UTC(y,m-1,d));
      if (isNaN(tmp)) return null;
      const dayNum = tmp.getUTCDay() || 7;
      tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(),0,1));
      return Math.ceil((((tmp - yearStart)/86400000)+1)/7);
    }
    function parseWeek(dateStr,y,m,d){
      if (y && m && d) return toISOWeekFromParts(parseInt(y,10),parseInt(m,10),parseInt(d,10));
      if (!dateStr) return null;
      const t = String(dateStr).trim();
      let match = t.match(/^(\d{4})-(\d{2})-(\d{2})/);
      if (match) return toISOWeekFromParts(+match[1],+match[2],+match[3]);
      match = t.match(/^(\d{4})-(\d{2})$/);
      if (match) return toISOWeekFromParts(+match[1],+match[2],15);
      match = t.match(/^(\d{4})$/);
      if (match) return toISOWeekFromParts(+match[1],6,30);
      const djs = new Date(t);
      if (!isNaN(djs)) return toISOWeekFromParts(djs.getUTCFullYear(),djs.getUTCMonth()+1,djs.getUTCDate());
      return null;
    }
    function isValidCoord(lat,lon){
      const la = parseFloat(lat), lo = parseFloat(lon);
      return isFinite(la) && isFinite(lo) && la>=-90 && la<=90 && lo>=-180 && lo<=180;
    }

    function addRecordToWeek(week, lat, lon, weight=1){
      const arr = weeklyData.get(week) || [];
      arr.push([parseFloat(lat), parseFloat(lon), parseFloat(weight) || 1]);
      weeklyData.set(week, arr);
    }

    // UI: weeks grid
    function drawWeeksGrid(){
      timelineWrap.innerHTML = ''; // Clear existing
      
      const monthsLayer = document.createElement('div');
      monthsLayer.className = 'months-layer';
      
      const weeksLayer = document.createElement('div');
      weeksLayer.className = 'weeks-layer';
      
      timelineWrap.appendChild(monthsLayer);
      timelineWrap.appendChild(weeksLayer);
      timelineWrap.appendChild(marker);
      timelineWrap.appendChild(markerHead);

      // 1. Draw Month Labels (Precise overlay)
      const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const daysInMonth = [31, 28.25, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // Avg for leap handling? Or just 365.
      // Let's use standard 365-day year ratio to align with the 52 weeks (364 days).
      // 52 weeks = 364 days.
      // We map the 365 calendar days onto the 364-day grid.
      // Day 1 = 0%. Day 365 = 100% (approx).
      
      const totalDays = 365.25; 
      let currentDay = 0;
      
      for(let i=0; i<12; i++){
        const div = document.createElement('div');
        div.className = 'month-label';
        div.textContent = monthNames[i];
        
        const startPct = (currentDay / totalDays) * 100;
        const widthPct = (daysInMonth[i] / totalDays) * 100;
        
        div.style.left = `${startPct}%`;
        div.style.width = `${widthPct}%`;
        
        monthsLayer.appendChild(div);
        currentDay += daysInMonth[i];
      }

      // 2. Draw 52 Week Cells
      for (let w=1; w<=52; w++){
        const div = document.createElement('div');
        div.className = 'week-cell';
        div.dataset.week = w;
        div.textContent = w; // Optional: Show number
        div.title = `Week ${w}`;
        
        // Check if data exists (merge 53 into 52 if needed)
        let hasData = weeklyData.has(w);
        if (w === 52 && weeklyData.has(53)) hasData = true;

        if (hasData) {
          div.classList.add('has-data');
          div.style.background = 'linear-gradient(to top, rgba(63,185,80,0.12), transparent)';
        }
        
        div.addEventListener('click', ()=>{
          if (weeklyData.has(w)) renderWeek(w);
          else if (w === 52 && weeklyData.has(53)) renderWeek(53);
        });
        
        weeksLayer.appendChild(div);
      }
    }

    function moveMarkerToWeekIndex(idx){
      // idx is the index in availableWeeks array
      if(idx < 0 || idx >= availableWeeks.length) return;
      const weekNum = availableWeeks[idx];
      // Clamp visual marker to 52
      const visualWeek = Math.min(weekNum, 52);
      
      const el = document.querySelector(`.week-cell[data-week="${visualWeek}"]`);
      if(!el) return;
      
      const wrapRect = timelineWrap.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      
      const relativeLeft = elRect.left - wrapRect.left;
      const center = relativeLeft + (elRect.width / 2);
      
      marker.style.transform = `translateX(${center}px)`;
      markerHead.style.left = `${center}px`;
      
      document.querySelectorAll('.week-cell.active').forEach(c => c.classList.remove('active'));
      el.classList.add('active');
    }

    function weekLabelText(week){
      const syntheticYear = 2020;
      function isoWeekStart(year,wk){
        const simple = new Date(Date.UTC(year,0,1 + (wk-1)*7));
        const dow = simple.getUTCDay();
        const ISOweekStart = new Date(simple);
        if (dow <= 4 && dow > 0) ISOweekStart.setUTCDate(simple.getUTCDate() - simple.getUTCDay() + 1);
        else ISOweekStart.setUTCDate(simple.getUTCDate() + (8 - simple.getUTCDay()));
        return ISOweekStart;
      }
      const d = isoWeekStart(syntheticYear, Math.min(Math.max(week,1),53));
      const day = d.getUTCDate();
      const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      return `${day} ${monthNames[d.getUTCMonth()]}`;
    }

    // Render week
    function renderWeek(week){
      const data = weeklyData.get(week) || [];
      heatLayer.setLatLngs(data);
      const idx = availableWeeks.indexOf(week);
      if (idx !== -1){
        currentWeekIndex = idx;
        moveMarkerToWeekIndex(idx);
        const label = weekLabelText(week);
        markerHead.textContent = label;
        // weekSelect update removed
      }
    }

    function updateAvailableWeeks(){
      availableWeeks = Array.from(weeklyData.keys()).sort((a,b)=>a-b);
      // weekSelect update removed
      drawWeeksGrid();
      if (availableWeeks.length){
        renderWeek(availableWeeks[0]);
      }
    }

    // Playback (single toggle)
    function play(intervalMs){
      if (!availableWeeks.length) return;
      isPlaying = true;
      togglePlayBtn.textContent = 'Pause';
      const interval = intervalMs || parseInt(intervalSelect.value,10);
      if (animationTimer) clearInterval(animationTimer);
      animationTimer = setInterval(()=>{
        renderWeek(availableWeeks[currentWeekIndex]);
        currentWeekIndex = (currentWeekIndex + 1) % availableWeeks.length;
      }, interval);
    }
    function pause(){
      isPlaying = false;
      togglePlayBtn.textContent = 'Play';
      if (animationTimer) clearInterval(animationTimer);
      animationTimer = null;
    }
    function togglePlay(){
      if (isPlaying) pause(); else play();
    }

    // --- make interval changes dynamic while playing ---
    function restartPlaybackWithNewInterval() {
      if (!isPlaying) return;
      if (animationTimer) clearInterval(animationTimer);
      const interval = parseInt(intervalSelect.value, 10) || 250;
      animationTimer = setInterval(() => {
        renderWeek(availableWeeks[currentWeekIndex]);
        currentWeekIndex = (currentWeekIndex + 1) % availableWeeks.length;
      }, interval);
    }
    intervalSelect.addEventListener('change', () => {
      if (isPlaying) restartPlaybackWithNewInterval();
    });

    // Wire playback UI
    togglePlayBtn.addEventListener('click', ()=> togglePlay());
    prevBtn.addEventListener('click', ()=>{ pause(); if (!availableWeeks.length) return; currentWeekIndex = (currentWeekIndex - 1 + availableWeeks.length) % availableWeeks.length; renderWeek(availableWeeks[currentWeekIndex]); });
    nextBtn.addEventListener('click', ()=>{ pause(); if (!availableWeeks.length) return; currentWeekIndex = (currentWeekIndex + 1) % availableWeeks.length; renderWeek(availableWeeks[currentWeekIndex]); });
    // weekSelect listener removed

    // Spacebar toggles play/pause (unless focused on an input)
    window.addEventListener('keydown', (e) => {
      const active = document.activeElement;
      const isInput = active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.tagName === 'SELECT' || active.isContentEditable);
      if (e.code === 'Space' && !isInput) {
        e.preventDefault();
        if (!togglePlayBtn.disabled) togglePlay();
      }
    });

    // --- Video Export ---
    downloadVideoBtn.addEventListener('click', async () => {
      if (!availableWeeks.length) return;
      pause();
      const mainPanel = document.getElementById('mainPanel');
      if (!mainPanel) return;

      // Setup
      showOverlay(true, 'Initializing video export...');
      overlayTitle.textContent = 'Creating Video';
      debugLog.innerHTML = ''; // Clear old logs
      progressBar.style.width = '0%';
      
      const layout = videoLayoutSelect.value;
      const isPhone = layout === 'phone';
      
      if (isPhone) {
        document.body.classList.add('export-mode-phone');
        // Wait for CSS transitions/redraw
        await new Promise(r => setTimeout(r, 400));
      }

      const canvas = document.createElement('canvas');
      const rect = mainPanel.getBoundingClientRect();
      
      // 1.5x Resolution for better quality without being too heavy
      const scaleFactor = 1.5;
      
      // Banner Config
      let bannerHeight = 0;
      if (isPhone) {
        bannerHeight = 100 * scaleFactor; // 100px visual height for banner
      }
      
      canvas.width = rect.width * scaleFactor;
      canvas.height = (rect.height * scaleFactor) + bannerHeight;
      const ctx = canvas.getContext('2d');
      
      // Stream setup (30fps)
      // Determine mime type (Prefer MP4 for social media)
      let mimeType = 'video/webm; codecs=vp9';
      let ext = 'webm';
      if (MediaRecorder.isTypeSupported('video/mp4')) {
        mimeType = 'video/mp4';
        ext = 'mp4';
      }
      
      const stream = canvas.captureStream(30);
      const recorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 2500000 }); // 2.5 Mbps
      const chunks = [];
      recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
      
      // Get selected interval
      const interval = parseInt(intervalSelect.value, 10) || 500;
      
      recorder.start();
      recorder.pause(); 

      try {
        for (let i = 0; i < availableWeeks.length; i++) {
          if (cancelled) break;
          const week = availableWeeks[i];
          renderWeek(week);
          statusText.textContent = `Rendering frame ${i+1}/${availableWeeks.length} (Week ${week})...`;
          progressBar.style.width = `${((i+1) / availableWeeks.length) * 100}%`;
          
          await new Promise(r => setTimeout(r, 150));
          
          const shot = await html2canvas(mainPanel, {
            useCORS: true,
            scale: scaleFactor, 
            logging: false,
            ignoreElements: (el) => el.classList.contains('overlay') 
          });
          
          // Clear and draw
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          if (isPhone) {
             // Draw Banner Background
             ctx.fillStyle = '#000000';
             ctx.fillRect(0, 0, canvas.width, bannerHeight);
             
             // Draw Species Name
             const name = mapSpeciesLabel.textContent.trim() || "Weekly Trend";
             ctx.fillStyle = '#ffffff';
             ctx.font = `bold ${32 * scaleFactor}px system-ui`;
             ctx.textAlign = 'center';
             ctx.textBaseline = 'bottom';
             ctx.fillText(name, canvas.width/2, bannerHeight * 0.45);
             
             // Draw Citation
             const cit = fileInput.dataset.gbifCitation || "";
             if (cit) {
                 ctx.fillStyle = '#ffffff';
                 ctx.font = `${16 * scaleFactor}px system-ui`;
                 ctx.textBaseline = 'top';
                 // Simple truncation if too long
                 let displayCit = cit;
                 if (cit.length > 90) displayCit = cit.substring(0, 90) + "...";
                 ctx.fillText(displayCit, canvas.width/2, bannerHeight * 0.55);
             }
             
             // Draw Screenshot shifted down
             ctx.drawImage(shot, 0, bannerHeight);
          } else {
             ctx.drawImage(shot, 0, 0); 
          }
          
          recorder.resume();
          await new Promise(r => setTimeout(r, interval));
          recorder.pause();
        }
      } catch (e) {
        console.error(e);
        showError('Video export failed: ' + e.message);
      } finally {
        if (isPhone) {
            document.body.classList.remove('export-mode-phone');
        }
        recorder.stop();
        await new Promise(r => recorder.onstop = r);
        const blob = new Blob(chunks, { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        // Generate filename
        let filename = 'weekly_trend';
        const name = mapSpeciesLabel.textContent.trim();
        if (name) {
            // Sanitize
            filename = name.replace(/[^a-z0-9]/gi, '_').toLowerCase() + '-weeklytrend';
        }
        
        a.download = `${filename}_${new Date().toISOString().slice(0,10)}.${ext}`;
        a.click();
        URL.revokeObjectURL(url);
        
        showOverlay(false);
        renderWeek(availableWeeks[0]);
      }
    });
    // Cancel parsing
    cancelBtn.addEventListener('click', ()=>{
      cancelled = true;
      if (parserInstance && typeof parserInstance.abort === 'function') {
        try { parserInstance.abort(); } catch(e){ /* ignore */ }
      }
      showOverlay(false);
      cancelBtn.style.display = 'none';
      log('Parsing cancelled by user.');
    });

    /************************************************************************
     * Robust parsing using Papa.parse chunk + non-blocking slices
     * Also: detect common name from uploaded file and set header text.
     ************************************************************************/

    function detectCommonNameFromRow(row){
      if (!row || typeof row !== 'object') return null;
      const keys = Object.keys(row).map(k => k.toLowerCase());
      const candidates = ['vernacularname','commonname','species','speciesname','taxon','scientificname','taxonname','vernacularName','commonName'];
      for (const c of candidates){
        for (const k of Object.keys(row)){
          if (k.toLowerCase() === c && row[k]) return String(row[k]).trim();
        }
      }
      for (const k of Object.keys(row)){
        const v = row[k];
        if (!v) continue;
        const s = String(v);
        const m = s.match(/\(([^)]+)\)/);
        if (m && m[1]) return m[1].trim();
      }
      return null;
    }

    function setBrandFromCommonName(name){
      // Check if manual name exists
      const manual = fileInput.dataset.manualSpeciesName;
      const display = manual || name;
      
      if (!display) {
        brandText.textContent = 'Weekly trend';
        mapSpeciesLabel.style.display = 'none';
      } else {
        brandText.textContent = `${display} - Weekly trend`;
        mapSpeciesLabel.textContent = display;
        mapSpeciesLabel.style.display = 'block';
      }
    }

    fileInput.addEventListener('change', ()=>{
      const file = fileInput.files[0];
      if (!file) return;

      // reset
      weeklyData = new Map(); availableWeeks = []; totalRecords = 0; currentWeekIndex = 0;
      heatLayer.setLatLngs([]); recordCount.textContent = '0';
      clearError(); debugLog.innerHTML = ''; drawWeeksGrid();
      togglePlayBtn.disabled = true; // will enable after parse
      cancelled = false;
      setBrandFromCommonName(null); // reset brand until detected

      showOverlay(true, `Reading ${Math.round(file.size/1024/1024)} MB…`);
      setProgress(0, 'Starting parse…');
      log('Selected file: ' + file.name + ' (' + Math.round(file.size/1024/1024) + ' MB)');

      // quick delimiter check
      const headReader = new FileReader();
      headReader.onload = ()=>{
        const head = headReader.result.slice(0,50000);
        const tabCount = (head.match(/\t/g) || []).length;
        const commaCount = (head.match(/,/g) || []).length;
        if (tabCount < 3 && commaCount > tabCount){
          showOverlay(false);
          showError('File appears comma-delimited; please upload tab-delimited occurrence.txt.');
          return;
        }
        // start streaming parse
        startStreamingParse(file);
      };
      headReader.readAsText(file.slice(0, Math.min(1024*64, file.size)));
    });

    function startStreamingParse(file){
      let headerValidated = false;
      let invalidHeader = false;
      let processedBytes = 0;
      let detectedCommonName = null;

      function handleChunkRows(rows, doneChunk){
        if (cancelled) { doneChunk(); return; }
        
        // If manual name provided, set it immediately and skip detection
        if (fileInput.dataset.manualSpeciesName) {
             setBrandFromCommonName(null); // Will use manual
        } else if (!detectedCommonName){
          for (let r of rows){
            const cn = detectCommonNameFromRow(r);
            if (cn) { detectedCommonName = cn; setBrandFromCommonName(cn); break; }
          }
        }
        let i = 0;
        function processSlice(){
          if (cancelled) { doneChunk(); return; }
          const end = Math.min(i + SLICE_ROWS, rows.length);
          for (; i < end; i++){
            const data = rows[i];
            const lat = data['decimalLatitude'];
            const lon = data['decimalLongitude'];
            const dateStr = data['eventDate'] || data['verbatimEventDate'] || null;
            const y = data['year'], m = data['month'], d = data['day'];
            if (!isValidCoord(lat,lon)) continue;
            const week = parseWeek(dateStr, y, m, d);
            if (week == null || week < 1 || week > 53) continue;
            let weight = 1;
            if (data['individualCount'] !== undefined && data['individualCount'] !== '') {
              const w = parseFloat(data['individualCount']);
              if (!isNaN(w) && w > 0) weight = w;
            } else if (data['occurrenceCount'] !== undefined && data['occurrenceCount'] !== '') {
              const w = parseFloat(data['occurrenceCount']);
              if (!isNaN(w) && w > 0) weight = w;
            }
            addRecordToWeek(week, lat, lon, weight);
            totalRecords++;
          }
          setProgress(Math.min(99, (processedBytes / file.size) * 100), `Parsed ${totalRecords.toLocaleString()} rows…`);
          recordCount.textContent = totalRecords.toLocaleString();
          if (i < rows.length) {
            setTimeout(processSlice, 0);
          } else {
            doneChunk();
          }
        }
        processSlice();
      }

      cancelled = false;
      cancelBtn.style.display = 'inline-block';
      try {
        parserInstance = Papa.parse(file, {
          header: true,
          delimiter: '\t',
          worker: USE_WORKER,
          skipEmptyLines: true,
          chunkSize: CHUNK_SIZE,
          chunk: function(results, parser){
            if (cancelled) { parser.abort(); return; }
            const rows = results.data;
            processedBytes = results.meta && results.meta.cursor ? results.meta.cursor : processedBytes;
            if (!headerValidated){
              headerValidated = true;
              const cols = Object.keys(rows[0] || {});
              const hasCoords = cols.includes('decimalLatitude') && cols.includes('decimalLongitude');
              const hasDate = cols.includes('eventDate') || (cols.includes('year') && cols.includes('month') && cols.includes('day')) || cols.includes('verbatimEventDate');
              if (!hasCoords || !hasDate){
                invalidHeader = true;
                parser.abort();
                showOverlay(false);
                showError('Missing required headers: eventDate/verbatimEventDate or year/month/day, and decimalLatitude/decimalLongitude.');
                return;
              }
              const cn = detectCommonNameFromRow(rows[0]);
              if (cn) { setBrandFromCommonName(cn); }
            }
            parser.pause();
            handleChunkRows(rows, ()=>{
              if (!cancelled) parser.resume();
            });
          },
          complete: function(){
            cancelBtn.style.display = 'none';
            if (invalidHeader) return;
            setProgress(99, 'Finalizing frames…');
            downsampleWeekArrays(20000);
            updateAvailableWeeks();
            showOverlay(false);
            if (availableWeeks.length){
              togglePlayBtn.disabled = false;
              currentWeekIndex = 0;
              renderWeek(availableWeeks[0]);
              setTimeout(()=>map.invalidateSize(),50);
            } else {
              showError('No valid weekly frames constructed (dates may be non-week-resolvable).');
            }
          },
          error: function(err){
            cancelBtn.style.display = 'none';
            showOverlay(false);
            showError('Parsing error: ' + (err && err.message ? err.message : String(err)));
          }
        });
      } catch (e){
        cancelBtn.style.display = 'none';
        showOverlay(true, 'Chunked parse failed; falling back to manual slice read');
        log('Papa.parse chunk failed: ' + (e && e.message ? e.message : String(e)));
        fallbackManualRead(file);
      }
    }

    // Fallback manual read
    function fallbackManualRead(file){
      const SLICE_BYTES = 1024 * 1024 * 1; // 1MB
      let offset = 0;
      let headerValidated = false;
      let invalidHeader = false;
      let detectedCommonName = null;

      function readNextSlice(){
        if (offset >= file.size) {
          setProgress(99, 'Finalizing frames…');
          downsampleWeekArrays(20000);
          updateAvailableWeeks();
          showOverlay(false);
          if (availableWeeks.length){
            togglePlayBtn.disabled = false;
            currentWeekIndex = 0;
            renderWeek(availableWeeks[0]);
            setTimeout(()=>map.invalidateSize(),50);
          } else {
            showError('No valid weekly frames constructed.');
          }
          return;
        }
        const end = Math.min(offset + SLICE_BYTES, file.size);
        const slice = file.slice(offset, end);
        const reader = new FileReader();
        reader.onload = () => {
          const text = reader.result;
          const config = {
            header: offset === 0,
            delimiter: '\t',
            skipEmptyLines: true
          };
          const parsed = Papa.parse(text, config);
          if (parsed && parsed.data && parsed.data.length){
            if (!headerValidated && parsed.meta && parsed.meta.fields){
              headerValidated = true;
              const cols = parsed.meta.fields;
              const hasCoords = cols.includes('decimalLatitude') && cols.includes('decimalLongitude');
              const hasDate = cols.includes('eventDate') || (cols.includes('year') && cols.includes('month') && cols.includes('day')) || cols.includes('verbatimEventDate');
              if (!hasCoords || !hasDate){
                invalidHeader = true;
                showOverlay(false);
                showError('Missing required headers: eventDate/year/month/day and decimalLatitude/decimalLongitude.');
                return;
              }
              const cn = detectCommonNameFromRow(parsed.data[0]);
              if (cn) { detectedCommonName = cn; setBrandFromCommonName(cn); }
            }
            let rows = parsed.data;
            if (!detectedCommonName){
              for (let r of rows){
                const cn = detectCommonNameFromRow(r);
                if (cn) { detectedCommonName = cn; setBrandFromCommonName(cn); break; }
              }
            }
            let i = 0;
            function processSliceRows(){
              const endIdx = Math.min(i + SLICE_ROWS, rows.length);
              for (; i < endIdx; i++){
                const data = rows[i];
                const lat = data['decimalLatitude'];
                const lon = data['decimalLongitude'];
                const dateStr = data['eventDate'] || data['verbatimEventDate'] || null;
                const y = data['year'], m = data['month'], d = data['day'];
                if (!isValidCoord(lat,lon)) continue;
                const week = parseWeek(dateStr, y, m, d);
                if (week == null || week < 1 || week > 53) continue;
                let weight = 1;
                if (data['individualCount'] !== undefined && data['individualCount'] !== '') {
                  const w = parseFloat(data['individualCount']);
                  if (!isNaN(w) && w > 0) weight = w;
                } else if (data['occurrenceCount'] !== undefined && data['occurrenceCount'] !== '') {
                  const w = parseFloat(data['occurrenceCount']);
                  if (!isNaN(w) && w > 0) weight = w;
                }
                addRecordToWeek(week, lat, lon, weight);
                totalRecords++;
              }
              setProgress(Math.min(99, (end / file.size) * 100), `Parsed ${totalRecords.toLocaleString()} rows…`);
              recordCount.textContent = totalRecords.toLocaleString();
              if (i < rows.length) setTimeout(processSliceRows, 0);
              else {
                offset = end;
                setTimeout(readNextSlice, 0);
              }
            }
            processSliceRows();
          } else {
            offset = end;
            setTimeout(readNextSlice, 0);
          }
        };
        reader.onerror = () => {
          showOverlay(false);
          showError('File read error during fallback read.');
        };
        reader.readAsText(slice);
      }
      readNextSlice();
    }

    // Downsample large weekly arrays
    function downsampleWeekArrays(maxPerWeek=20000){
      weeklyData.forEach((arr, week)=>{
        if (arr.length > maxPerWeek){
          const factor = maxPerWeek / arr.length;
          const sampled = [];
          for (let i=0;i<arr.length;i++) if (Math.random() < factor) sampled.push(arr[i]);
          weeklyData.set(week, sampled);
        }
      });
    }

    // Keep marker aligned on resize
    window.addEventListener('resize', ()=> moveMarkerToWeekIndex(currentWeekIndex));

    // init
    drawWeeksGrid();
    log('Ready. Select occurrence.txt to start parsing.');

    /************************************************************************
     * Official India ADM0 overlay (geoBoundaries) integration
     ************************************************************************/

    const GEOJSON_URL = './geoBoundaries-IND-ADM0.geojson';

    function fetchGeoJSONViaXHR(url){
      return new Promise((resolve)=>{
        try {
          const xhr = new XMLHttpRequest();
          xhr.open('GET', url, true);
          xhr.overrideMimeType('application/json');
          xhr.onreadystatechange = () => {
            if (xhr.readyState !== 4) return;
            if (xhr.status === 0 || (xhr.status >= 200 && xhr.status < 300)){
              try {
                resolve(JSON.parse(xhr.responseText));
              } catch (e) {
                console.error('Failed to parse ADM0 JSON from XHR', e);
                resolve(null);
              }
            } else {
              resolve(null);
            }
          };
          xhr.onerror = () => resolve(null);
          xhr.send();
        } catch (err){
          console.error('XHR fallback failed', err);
          resolve(null);
        }
      });
    }

    async function fetchOfficialGeoJSON(){
      if (originalOfficialGeojson) {
        return originalOfficialGeojson;
      }
      try {
        const res = await fetch(GEOJSON_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const geo = await res.json();
        originalOfficialGeojson = geo;
        return geo;
      } catch (err) {
        console.error(err);
        const xhrGeo = await fetchGeoJSONViaXHR(GEOJSON_URL);
        if (xhrGeo) {
          originalOfficialGeojson = xhrGeo;
          window.ADM0_GEOJSON = xhrGeo;
          return xhrGeo;
        }
        showError('Failed to load official GeoJSON from geoBoundaries-IND-ADM0.geojson. Please ensure it is located beside this HTML file and is readable.');
        return null;
      }
    }

    function styleOfficialFeature(){
      return {
        color: '#666666',
        weight: 1.8,
        opacity: 0.95,
        fill: true,
        fillColor: '#f2efe9',
        fillOpacity: 0.12
      };
    }

    function addOfficialToMap(geojson){
      if (officialLayer) {
        map.removeLayer(officialLayer);
        officialLayer = null;
      }
      let processed = geojson;
      if (OFFICIAL_SIMPLIFY_TOL && OFFICIAL_SIMPLIFY_TOL > 0) {
        try {
          processed = turf.simplify(geojson, { tolerance: OFFICIAL_SIMPLIFY_TOL, highQuality: false });
        } catch (e) {
          console.warn('Simplify failed, using original geojson', e);
          processed = geojson;
        }
      }
      officialLayer = L.geoJSON(processed, {
        style: styleOfficialFeature,
        pane: 'overlayPane',
        onEachFeature: function (feature, layer) {
          const props = feature.properties || {};
          const title = props.name || props.NAME || props.admin || 'India ADM0';
          layer.bindPopup(title);
        }
      });
      if (toggleOfficial.checked) officialLayer.addTo(map);
    }

    toggleOfficial.addEventListener('change', async (e) => {
      if (!originalOfficialGeojson) {
        const geo = await fetchOfficialGeoJSON();
        if (!geo) return;
        addOfficialToMap(geo);
        return;
      }
      if (!officialLayer) addOfficialToMap(originalOfficialGeojson);
      if (e.target.checked) {
        if (officialLayer && !map.hasLayer(officialLayer)) officialLayer.addTo(map);
      } else {
        if (officialLayer && map.hasLayer(officialLayer)) map.removeLayer(officialLayer);
      }
    });

    (async ()=> {
      const geo = await fetchOfficialGeoJSON();
      if (geo) addOfficialToMap(geo);
    })();

    // Ensure map resizes correctly after everything loads
    setTimeout(()=> map.invalidateSize(), 200);
  </script>
</body>
</html>
